// utils/notificationService.ts
import PushNotification from 'react-native-push-notification';
import AsyncStorage from '@react-native-async-storage/async-storage';
import messaging, {
  FirebaseMessagingTypes,
} from '@react-native-firebase/messaging';
import {Linking, Platform} from 'react-native';
import {API_BASE_URL} from '../config/api';
import {addToInbox} from './notificationInbox';

// ----- inbox record type -----
type InboxItem = {
  id: string;
  title?: string;
  message: string;
  timestamp: string;
  category?: 'news' | 'outfit' | 'weather' | 'care' | 'other';
  deeplink?: string;
  data?: Record<string, string>;
};

// ‚úÖ Helper: Map FCM ‚Üí InboxItem
function mapMessage(msg: FirebaseMessagingTypes.RemoteMessage): InboxItem {
  const id =
    msg.messageId ?? `${Date.now()}-${Math.random().toString(36).slice(2, 8)}`;
  const title = msg.notification?.title ?? msg.data?.title ?? undefined;
  const message =
    msg.notification?.body ?? msg.data?.body ?? msg.data?.message ?? '';
  const deeplink = msg.data?.deeplink;
  const category = (msg.data?.category as InboxItem['category']) ?? 'other';

  return {
    id,
    title,
    message,
    timestamp: new Date().toISOString(),
    category,
    deeplink,
    data: msg.data ?? {},
  };
}

// Keep references to unsubscribers so we don‚Äôt double-register listeners
let fgUnsub: (() => void) | null = null;
let openUnsub: (() => void) | null = null;
let fgRegistered = false;

// üî• Used to suppress duplicate banners
let lastShownId: string | null = null;

export const initializeNotifications = async (userId?: string) => {
  try {
    const enabled = await AsyncStorage.getItem('notificationsEnabled');
    if (enabled !== 'true') {
      console.log('üîï Notifications disabled. Skipping initialization.');
      return;
    }

    console.log('‚ö°Ô∏è Initializing notifications‚Ä¶');

    // üîî Local notification setup (Android heads-up support)
    PushNotification.configure({
      onNotification: n => console.log('üîî Local notification:', n),
      requestPermissions: true,
    });

    PushNotification.createChannel(
      {
        channelId: 'style-channel',
        channelName: 'Style Alerts',
        importance: 4,
        vibrate: true,
        soundName: 'default',
      },
      created => console.log(`üì° Channel ${created ? 'created' : 'exists'}`),
    );

    if (!userId) {
      console.warn('‚ö†Ô∏è No userId provided. Skipping token registration.');
      return;
    }

    // üîê Request push permissions
    const status = await messaging().requestPermission();
    const granted =
      status === messaging.AuthorizationStatus.AUTHORIZED ||
      status === messaging.AuthorizationStatus.PROVISIONAL;
    console.log('üìõ Push permission status:', status, 'granted=', granted);

    await messaging().registerDeviceForRemoteMessages();

    const fcmToken = await messaging().getToken();
    console.log(
      'üé´ FCM token:',
      fcmToken ? fcmToken.slice(0, 28) + '‚Ä¶' : '(null)',
    );

    // üîç Gather Firebase project metadata
    let senderId: string | undefined;
    let projectId: string | undefined;
    try {
      const opts = (messaging() as any).app?.options || {};
      senderId = opts.messagingSenderId;
      projectId = opts.projectId;
    } catch {}
    console.log('üè∑Ô∏è Firebase opts:', {senderId, projectId});

    // üì° Register token with backend
    if (fcmToken) {
      const r = await fetch(`${API_BASE_URL}/notifications/register`, {
        method: 'POST',
        headers: {'Content-Type': 'application/json'},
        body: JSON.stringify({
          user_id: userId,
          device_token: fcmToken,
          platform: Platform.OS,
          sender_id: senderId,
          project_id: projectId,
        }),
      });
      const j = await r.json().catch(() => ({}));
      console.log('üì® /notifications/register =>', r.status, j);
    } else {
      console.warn('‚ö†Ô∏è No FCM token; cannot register.');
    }

    // üßπ Clean up any old listeners
    fgUnsub?.();
    openUnsub?.();
    fgUnsub = null;
    openUnsub = null;
    fgRegistered = false;
    lastShownId = null;

    // üì¨ Foreground push ‚Üí show banner (only once)
    if (!fgRegistered) {
      fgUnsub = messaging().onMessage(async msg => {
        const mapped = mapMessage(msg);
        console.log('üì© Foreground push:', mapped.id);

        // ‚úÖ Skip banner if we've already shown this message ID
        if (mapped.id === lastShownId) {
          console.log('‚ö†Ô∏è Skipping duplicate banner for:', mapped.id);
          return;
        }
        lastShownId = mapped.id;

        // üîî Show local banner (but DO NOT add to inbox here to prevent duplicates)
        try {
          PushNotification.localNotification({
            channelId: 'style-channel',
            title: mapped.title || 'Notification',
            message: mapped.message || '',
            userInfo: mapped,
            playSound: true,
          });
        } catch (e) {
          console.warn('‚ö†Ô∏è Failed to show local notification', e);
        }
      });
      fgRegistered = true;
    }

    // üì¨ Tapped from background ‚Üí persist + open link
    openUnsub = messaging().onNotificationOpenedApp(async msg => {
      const mapped = mapMessage(msg);
      await addToInbox(mapped);
      if (mapped.deeplink) {
        try {
          await Linking.openURL(mapped.deeplink);
        } catch {}
      }
    });

    // üì¨ Tapped from quit (cold start)
    const initial = await messaging().getInitialNotification();
    if (initial) {
      const mapped = mapMessage(initial);
      await addToInbox(mapped);
      if (mapped.deeplink) {
        try {
          await Linking.openURL(mapped.deeplink);
        } catch {}
      }
    }

    // üîÑ Token refresh ‚Üí register again
    messaging().onTokenRefresh(async newTok => {
      console.log('üîÑ FCM token refreshed:', newTok.slice(0, 28) + '‚Ä¶');
      try {
        await fetch(`${API_BASE_URL}/notifications/register`, {
          method: 'POST',
          headers: {'Content-Type': 'application/json'},
          body: JSON.stringify({
            user_id: userId,
            device_token: newTok,
            platform: Platform.OS,
            sender_id: senderId,
            project_id: projectId,
          }),
        });
      } catch (e) {
        console.log('‚ö†Ô∏è register(refresh) failed:', e);
      }
    });

    console.log('‚úÖ Push initialized, listeners armed, inbox enabled');
  } catch (err) {
    console.error('‚ùå initializeNotifications error:', err);
  }
};

////////////////////////

// // utils/notificationService.ts
// import PushNotification from 'react-native-push-notification';
// import AsyncStorage from '@react-native-async-storage/async-storage';
// import messaging, {
//   FirebaseMessagingTypes,
// } from '@react-native-firebase/messaging';
// import {Linking, Platform} from 'react-native';
// import {API_BASE_URL} from '../config/api';
// import {addToInbox} from './notificationInbox';

// // ----- inbox record type -----
// type InboxItem = {
//   id: string;
//   title?: string;
//   message: string;
//   timestamp: string;
//   category?: 'news' | 'outfit' | 'weather' | 'care' | 'other';
//   deeplink?: string;
//   data?: Record<string, string>;
// };

// // ‚úÖ Helper: Map FCM ‚Üí InboxItem
// function mapMessage(msg: FirebaseMessagingTypes.RemoteMessage): InboxItem {
//   const id =
//     msg.messageId ?? `${Date.now()}-${Math.random().toString(36).slice(2, 8)}`;
//   const title = msg.notification?.title ?? msg.data?.title ?? undefined;
//   const message =
//     msg.notification?.body ?? msg.data?.body ?? msg.data?.message ?? '';
//   const deeplink = msg.data?.deeplink;
//   const category = (msg.data?.category as InboxItem['category']) ?? 'other';

//   return {
//     id,
//     title,
//     message,
//     timestamp: new Date().toISOString(),
//     category,
//     deeplink,
//     data: msg.data ?? {},
//   };
// }

// // Keep references to unsubscribers so we don‚Äôt double-register listeners
// let fgUnsub: (() => void) | null = null;
// let openUnsub: (() => void) | null = null;
// let fgRegistered = false;

// // üî• Used to suppress duplicate banners
// let lastShownId: string | null = null;

// export const initializeNotifications = async (userId?: string) => {
//   try {
//     const enabled = await AsyncStorage.getItem('notificationsEnabled');
//     if (enabled !== 'true') {
//       console.log('üîï Notifications disabled. Skipping initialization.');
//       return;
//     }

//     console.log('‚ö°Ô∏è Initializing notifications‚Ä¶');

//     // üîî Local notification setup (Android heads-up support)
//     PushNotification.configure({
//       onNotification: n => console.log('üîî Local notification:', n),
//       requestPermissions: true,
//     });

//     PushNotification.createChannel(
//       {
//         channelId: 'style-channel',
//         channelName: 'Style Alerts',
//         importance: 4,
//         vibrate: true,
//         soundName: 'default',
//       },
//       created => console.log(`üì° Channel ${created ? 'created' : 'exists'}`),
//     );

//     if (!userId) {
//       console.warn('‚ö†Ô∏è No userId provided. Skipping token registration.');
//       return;
//     }

//     // üîê Request push permissions
//     const status = await messaging().requestPermission();
//     const granted =
//       status === messaging.AuthorizationStatus.AUTHORIZED ||
//       status === messaging.AuthorizationStatus.PROVISIONAL;
//     console.log('üìõ Push permission status:', status, 'granted=', granted);

//     await messaging().registerDeviceForRemoteMessages();

//     const fcmToken = await messaging().getToken();
//     console.log(
//       'üé´ FCM token:',
//       fcmToken ? fcmToken.slice(0, 28) + '‚Ä¶' : '(null)',
//     );

//     // üîç Gather Firebase project metadata
//     let senderId: string | undefined;
//     let projectId: string | undefined;
//     try {
//       const opts = (messaging() as any).app?.options || {};
//       senderId = opts.messagingSenderId;
//       projectId = opts.projectId;
//     } catch {}
//     console.log('üè∑Ô∏è Firebase opts:', {senderId, projectId});

//     // üì° Register token with backend
//     if (fcmToken) {
//       const r = await fetch(`${API_BASE_URL}/notifications/register`, {
//         method: 'POST',
//         headers: {'Content-Type': 'application/json'},
//         body: JSON.stringify({
//           user_id: userId,
//           device_token: fcmToken,
//           platform: Platform.OS,
//           sender_id: senderId,
//           project_id: projectId,
//         }),
//       });
//       const j = await r.json().catch(() => ({}));
//       console.log('üì® /notifications/register =>', r.status, j);
//     } else {
//       console.warn('‚ö†Ô∏è No FCM token; cannot register.');
//     }

//     // üßπ Clean up any old listeners
//     fgUnsub?.();
//     openUnsub?.();
//     fgUnsub = null;
//     openUnsub = null;
//     fgRegistered = false;
//     lastShownId = null;

//     // üì¨ Foreground push ‚Üí show banner (only once)
//     if (!fgRegistered) {
//       fgUnsub = messaging().onMessage(async msg => {
//         const mapped = mapMessage(msg);
//         console.log('üì© Foreground push:', mapped.id);

//         // ‚úÖ Skip banner if we've already shown this message ID
//         if (mapped.id === lastShownId) {
//           console.log('‚ö†Ô∏è Skipping duplicate banner for:', mapped.id);
//           return;
//         }
//         lastShownId = mapped.id;

//         // üîî Show local banner (but DO NOT add to inbox here to prevent duplicates)
//         try {
//           PushNotification.localNotification({
//             channelId: 'style-channel',
//             title: mapped.title || 'Notification',
//             message: mapped.message || '',
//             userInfo: mapped,
//             playSound: true,
//           });
//         } catch (e) {
//           console.warn('‚ö†Ô∏è Failed to show local notification', e);
//         }
//       });
//       fgRegistered = true;
//     }

//     // üì¨ Tapped from background ‚Üí persist + open link
//     openUnsub = messaging().onNotificationOpenedApp(async msg => {
//       const mapped = mapMessage(msg);
//       await addToInbox(mapped);
//       if (mapped.deeplink) {
//         try {
//           await Linking.openURL(mapped.deeplink);
//         } catch {}
//       }
//     });

//     // üì¨ Tapped from quit (cold start)
//     const initial = await messaging().getInitialNotification();
//     if (initial) {
//       const mapped = mapMessage(initial);
//       await addToInbox(mapped);
//       if (mapped.deeplink) {
//         try {
//           await Linking.openURL(mapped.deeplink);
//         } catch {}
//       }
//     }

//     // üîÑ Token refresh ‚Üí register again
//     messaging().onTokenRefresh(async newTok => {
//       console.log('üîÑ FCM token refreshed:', newTok.slice(0, 28) + '‚Ä¶');
//       try {
//         await fetch(`${API_BASE_URL}/notifications/register`, {
//           method: 'POST',
//           headers: {'Content-Type': 'application/json'},
//           body: JSON.stringify({
//             user_id: userId,
//             device_token: newTok,
//             platform: Platform.OS,
//             sender_id: senderId,
//             project_id: projectId,
//           }),
//         });
//       } catch (e) {
//         console.log('‚ö†Ô∏è register(refresh) failed:', e);
//       }
//     });

//     console.log('‚úÖ Push initialized, listeners armed, inbox enabled');
//   } catch (err) {
//     console.error('‚ùå initializeNotifications error:', err);
//   }
// };
